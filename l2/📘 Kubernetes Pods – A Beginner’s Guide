ğŸš€ Introduction

A Pod is the smallest deployable unit in Kubernetes. It represents one or more containers that share the same storage, network, and specifications on how to run.

In this guide, weâ€™ll learn:

âœ… What Pods are
âœ… How to create them (imperative & declarative)
âœ… How to inspect & debug them
âœ… How to modify them
âœ… Useful commands for working with Pods

âš¡ Ways to Create a Pod
There are two main ways to create Pods:

Method	When to Use	Example
Imperative	Quick, simple, minimal customization	kubectl run nginx --image=nginx --restart=Never
Declarative	For reusable, version-controlled configurations	Writing a YAML file (pod.yaml)

ğŸ”¹ 1. Imperative Approach
The imperative way is using direct kubectl commands.

ğŸ‘‰ Example:

kubectl run nginx-pod --image=nginx

âœ… Output:
pod/nginx-pod created
ğŸ‘‰ Verify here from this command 
kubectl get pods
This shows the list of running Pods.

ğŸ”¹ 2. Declarative Approach


The declarative way uses a YAML file to define the Pod.

Every Pod YAML has 4 top-level fields:

Field	Description
apiVersion	Kubernetes API version (for Pods it is usually v1)
kind	Resource type (e.g., Pod)
metadata	Information like name, labels, namespace
spec	The Pod specification, e.g., containers, images, ports

ğŸ‘‰ Sample pod.yaml:

apiVersion: v1
kind: Pod
metadata:
  name: nginx-pod
  labels:
    env: test
spec:
  containers:
    - name: nginx-container
      image: nginx:latest

ğŸ‘‰ Apply the YAML:
kubectl create -f pod.yaml

âœ… Output:
pod/nginx-pod created

ğŸ‘‰ Verify:
kubectl get pods
ğŸ“œ Generate YAML from Imperative Command
You donâ€™t always have to write YAML from scratch.
You can dry-run a command and output the YAML.

ğŸ‘‰ Example:
kubectl run nginx3 --image=nginx --dry-run=client -o yaml > pod3.yaml
Now you have pod3.yaml file that you can edit and apply.

kubectl apply -f pod3.yaml

ğŸ” Inspecting Pods

1. Logs
kubectl logs nginx-pod

ğŸ‘‰ Real-time logs:
kubectl logs -f nginx-pod

2. Describe Pod
kubectl describe pod nginx-pod

This shows:
Status
Events
Node assignment
Container details

Example event sequence:

arduino
Successfully assigned default/nginx-pod to worker-node1
Pulled image "nginx"
Created container nginx
Started container nginx

3. Show Labels
kubectl get pods --show-labels
âœï¸ Editing Pods
Two approaches:

1ï¸âƒ£ Edit live resource:
kubectl edit pod nginx3
2ï¸âƒ£ Edit YAML and re-apply:
kubectl apply -f pod3.yaml

âš™ï¸ Executing Inside a Pod
To get a shell inside the container:

kubectl exec -it nginx-pod -- /bin/bash

ğŸ‘‰ Now youâ€™re inside the container:
ls
cd /etc/nginx
Exit:
exit

ğŸ“Š Useful kubectl Commands Summary
Command	Description
kubectl run NAME --image=IMAGE	Create a pod imperatively
kubectl get pods	List pods
kubectl logs POD	View logs
kubectl logs -f POD	Stream logs
kubectl describe pod POD	View details
kubectl edit pod POD	Edit running pod
kubectl exec -it POD -- bash	Access shell inside container
kubectl apply -f FILE	Create/update resource from YAML
kubectl get pods -o wide	Show more details (node, IP, etc.)

ğŸ¯ Key Takeaways
Imperative = fast & simple.
Declarative = reusable & scalable.
Pods are usually managed by higher-level controllers (Deployments, ReplicaSets), but learning Pods is the foundation.
Always inspect Pods using kubectl describe when debugging.

âœ¨ With this, you now know how to create, inspect, and modify Kubernetes Pods using both imperative and declarative methods!
