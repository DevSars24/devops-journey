## ğŸ”¹ Introduction

In this session, we explored how to **expose an application externally** in Kubernetes using a **Service**. We went step by step:

1. Created a **Deployment**.
2. Created a **Service**.
3. Used a **Dockerized application** from earlier.
4. Pushed the image to **Docker Hub**.
5. Exposed the app via **NodePort Service**.

By the end, our **Hello World App** was running and accessible externally.

---

## ğŸ³ Step 1: Dockerizing the Application

* We already had a **Node.js app (`index.js`)** printing `Hello World from Dockerized app`.
* Dockerfile was ready from earlier.

### âœ… Build the Docker Image

```bash
docker build -t username/hello-app:latest .
```

### âœ… Push Image to Docker Hub

```bash
docker push username/hello-app:latest
```

ğŸ“Œ **Result:** Image is available on Docker Hub â†’ `username/hello-app:latest`

---

## ğŸš€ Step 2: Creating a Deployment

We generated a **deployment YAML** using `kubectl`.

```bash
kubectl create deploy hello-deploy \
  --image=username/hello-app:latest \
  --dry-run=client -o yaml > deployment.yaml
```

### âœï¸ Deployment YAML (final)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-deploy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: hello-app
  template:
    metadata:
      labels:
        app: hello-app
    spec:
      containers:
      - name: hello-container
        image: username/hello-app:latest
        ports:
        - containerPort: 3000
```

### âœ… Apply Deployment

```bash
kubectl apply -f deployment.yaml
kubectl get pods
```

ğŸ“Œ **Result:** 3 Pods running the application.

---

## ğŸŒ Step 3: Creating a Service

A Service helps us **expose the Deployment externally**.

### âœï¸ Service YAML (NodePort)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: hello-service
spec:
  type: NodePort
  selector:
    app: hello-app
  ports:
    - port: 80
      targetPort: 3000
      nodePort: 30080
```

### âœ… Apply Service

```bash
kubectl apply -f service.yaml
kubectl get svc
```

ğŸ“Œ **Result:** Service exposed at **NodePort 30080**.

---

## ğŸ–¥ï¸ Step 4: Accessing the Application

With **Minikube**, we use:

```bash
minikube service hello-service
```

â¡ï¸ Opens browser â†’ `Hello World from Dockerized app`

ğŸ“Œ **Flow of Request:**

```
User Request â†’ NodePort Service (30080) â†’ Target Port (3000) â†’ App Container
```

---

## âš ï¸ Debugging Issues

* âŒ CrashLoopBackOff errors â†’ `port already in use` (multiple replicas on same node).
* âœ… Fixed by ensuring **containerPort** and **service targetPort** match.

ğŸ“Œ Final working setup:

* **containerPort**: `3000`
* **service targetPort**: `3000`
* **service port**: `80`
* **nodePort**: `30080`

---

## ğŸ—‚ï¸ Summary Diagram

```text
           +-----------------------+
           |     User Browser      |
           +-----------+-----------+
                       |
                       v
         NodeIP:30080 (NodePort Service)
                       |
                       v
              +--------+--------+
              |   Pod 1 (App)   |
              |   Pod 2 (App)   |
              |   Pod 3 (App)   |
              +-----------------+
```

---

## âœ… Key Takeaways

* **Deployment** ensures replicas & scaling.
* **Service (NodePort)** exposes apps externally.
* **Docker Hub** helps distribute container images.
* **Minikube service command** provides quick access.

With this, we successfully exposed our **Hello App** externally! ğŸš€
