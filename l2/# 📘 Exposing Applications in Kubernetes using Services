## 🔹 Introduction

In this session, we explored how to **expose an application externally** in Kubernetes using a **Service**. We went step by step:

1. Created a **Deployment**.
2. Created a **Service**.
3. Used a **Dockerized application** from earlier.
4. Pushed the image to **Docker Hub**.
5. Exposed the app via **NodePort Service**.

By the end, our **Hello World App** was running and accessible externally.

---

## 🐳 Step 1: Dockerizing the Application

* We already had a **Node.js app (`index.js`)** printing `Hello World from Dockerized app`.
* Dockerfile was ready from earlier.

### ✅ Build the Docker Image

```bash
docker build -t username/hello-app:latest .
```

### ✅ Push Image to Docker Hub

```bash
docker push username/hello-app:latest
```

📌 **Result:** Image is available on Docker Hub → `username/hello-app:latest`

---

## 🚀 Step 2: Creating a Deployment

We generated a **deployment YAML** using `kubectl`.

```bash
kubectl create deploy hello-deploy \
  --image=username/hello-app:latest \
  --dry-run=client -o yaml > deployment.yaml
```

### ✍️ Deployment YAML (final)

```yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: hello-deploy
spec:
  replicas: 3
  selector:
    matchLabels:
      app: hello-app
  template:
    metadata:
      labels:
        app: hello-app
    spec:
      containers:
      - name: hello-container
        image: username/hello-app:latest
        ports:
        - containerPort: 3000
```

### ✅ Apply Deployment

```bash
kubectl apply -f deployment.yaml
kubectl get pods
```

📌 **Result:** 3 Pods running the application.

---

## 🌐 Step 3: Creating a Service

A Service helps us **expose the Deployment externally**.

### ✍️ Service YAML (NodePort)

```yaml
apiVersion: v1
kind: Service
metadata:
  name: hello-service
spec:
  type: NodePort
  selector:
    app: hello-app
  ports:
    - port: 80
      targetPort: 3000
      nodePort: 30080
```

### ✅ Apply Service

```bash
kubectl apply -f service.yaml
kubectl get svc
```

📌 **Result:** Service exposed at **NodePort 30080**.

---

## 🖥️ Step 4: Accessing the Application

With **Minikube**, we use:

```bash
minikube service hello-service
```

➡️ Opens browser → `Hello World from Dockerized app`

📌 **Flow of Request:**

```
User Request → NodePort Service (30080) → Target Port (3000) → App Container
```

---

## ⚠️ Debugging Issues

* ❌ CrashLoopBackOff errors → `port already in use` (multiple replicas on same node).
* ✅ Fixed by ensuring **containerPort** and **service targetPort** match.

📌 Final working setup:

* **containerPort**: `3000`
* **service targetPort**: `3000`
* **service port**: `80`
* **nodePort**: `30080`

---

## 🗂️ Summary Diagram

```text
           +-----------------------+
           |     User Browser      |
           +-----------+-----------+
                       |
                       v
         NodeIP:30080 (NodePort Service)
                       |
                       v
              +--------+--------+
              |   Pod 1 (App)   |
              |   Pod 2 (App)   |
              |   Pod 3 (App)   |
              +-----------------+
```

---

## ✅ Key Takeaways

* **Deployment** ensures replicas & scaling.
* **Service (NodePort)** exposes apps externally.
* **Docker Hub** helps distribute container images.
* **Minikube service command** provides quick access.

With this, we successfully exposed our **Hello App** externally! 🚀
