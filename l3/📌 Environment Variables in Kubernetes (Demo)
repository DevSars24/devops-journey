🎯 Lecture Overview

This session is a hands-on demo that walks through how to:

Create a Kubernetes Deployment
Add environment variables to containers
Rebuild & push Docker images
Expose applications using Services
Verify environment variables inside containers

🗂️ Step-by-Step Demo

1️⃣ Creating a Deployment

We start by creating a deployment with a public container image:

kubectl create deploy nginx \
  --image=piyush/hello-app:latest \
  --replicas=2 \
  --dry-run=client -o yaml > deployment.yaml
📝 This generates a deployment.yaml file.

Inside it, we define container ports and can later add environment variables.

2️⃣ Adding Environment Variables

In Kubernetes, environment variables are injected inside containers via the env field.

✅ Correct format:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
containers:
  - name: nginx
    image: piyush/hello-app:3.0
    ports:
      - containerPort: 3000
    env:
      - name: APP_NAME
        value: "Kubernetes 101"
      - name: APP_VERSION
        value: "3.0"
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
📌 Notes:

name: variable name (best practice → uppercase with underscores).

value: variable value.

3️⃣ Updating Application Code

Inside index.js, environment variables are accessed via process.env:

const port = process.env.PORT || 3000;
const appName = process.env.APP_NAME || "Kubernetes";

console.log(`Hello World from ${appName}`);

So instead of hardcoding, the app reads from injected variables. 🎉

4️⃣ Building & Pushing the Image

# Build new Docker image
docker build -t piyush/hello-app:3.0 .

# Push image to Docker Hub
docker push piyush/hello-app:3.0
📦 New image is now available for Kubernetes to pull.

5️⃣ Deploying Updated App

kubectl apply -f deployment.yaml
Check pods:

kubectl get pods
6️⃣ Exposing the Service
To access the application, expose the deployment via NodePort Service:

kubectl expose deploy nginx \
  --type=NodePort \
  --port=80 \
  --target-port=3000
Then check service details:

kubectl get svc
🔑 NodePort maps external port → container port (3000).

7️⃣ Verifying Environment Variables
👉 Option 1: Exec into pod

kubectl exec -it <pod-name> -- sh
printenv | grep APP_NAME
👉 Option 2: Run directly

kubectl exec <pod-name> -- printenv | grep APP_NAME
✅ Output should show:


APP_NAME=Kubernetes 101

📊 Summary Table

Step	Command / File	Purpose
1	kubectl create deploy ... -o yaml	Generate deployment YAML
2	env: block in YAML	Add environment variables
3	process.env.VAR_NAME	Access env vars in code
4	docker build & push	Build and push image
5	kubectl apply -f	Deploy updated app
6	kubectl expose deploy	Create service
7	kubectl exec printenv	Verify env vars

🔑 Key Takeaways

Environment variables in Kubernetes are injected at the container level.
Use env: field inside Deployment manifest.
Best practice → env var names in UPPERCASE.
Always rebuild & push Docker image after code changes.
Use Services (NodePort/ClusterIP/LoadBalancer) to expose applications.

You can verify env vars via kubectl exec or directly in app code.

✨ That’s it for this demo — now your app can flexibly adapt using environment variables in Kubernetes!
