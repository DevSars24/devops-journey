ğŸ¯ Lecture Overview

This session is a hands-on demo that walks through how to:

Create a Kubernetes Deployment
Add environment variables to containers
Rebuild & push Docker images
Expose applications using Services
Verify environment variables inside containers

ğŸ—‚ï¸ Step-by-Step Demo

1ï¸âƒ£ Creating a Deployment

We start by creating a deployment with a public container image:

kubectl create deploy nginx \
  --image=piyush/hello-app:latest \
  --replicas=2 \
  --dry-run=client -o yaml > deployment.yaml
ğŸ“ This generates a deployment.yaml file.

Inside it, we define container ports and can later add environment variables.

2ï¸âƒ£ Adding Environment Variables

In Kubernetes, environment variables are injected inside containers via the env field.

âœ… Correct format:
---------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
containers:
  - name: nginx
    image: piyush/hello-app:3.0
    ports:
      - containerPort: 3000
    env:
      - name: APP_NAME
        value: "Kubernetes 101"
      - name: APP_VERSION
        value: "3.0"
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
ğŸ“Œ Notes:

name: variable name (best practice â†’ uppercase with underscores).

value: variable value.

3ï¸âƒ£ Updating Application Code

Inside index.js, environment variables are accessed via process.env:

const port = process.env.PORT || 3000;
const appName = process.env.APP_NAME || "Kubernetes";

console.log(`Hello World from ${appName}`);

So instead of hardcoding, the app reads from injected variables. ğŸ‰

4ï¸âƒ£ Building & Pushing the Image

# Build new Docker image
docker build -t piyush/hello-app:3.0 .

# Push image to Docker Hub
docker push piyush/hello-app:3.0
ğŸ“¦ New image is now available for Kubernetes to pull.

5ï¸âƒ£ Deploying Updated App

kubectl apply -f deployment.yaml
Check pods:

kubectl get pods
6ï¸âƒ£ Exposing the Service
To access the application, expose the deployment via NodePort Service:

kubectl expose deploy nginx \
  --type=NodePort \
  --port=80 \
  --target-port=3000
Then check service details:

kubectl get svc
ğŸ”‘ NodePort maps external port â†’ container port (3000).

7ï¸âƒ£ Verifying Environment Variables
ğŸ‘‰ Option 1: Exec into pod

kubectl exec -it <pod-name> -- sh
printenv | grep APP_NAME
ğŸ‘‰ Option 2: Run directly

kubectl exec <pod-name> -- printenv | grep APP_NAME
âœ… Output should show:


APP_NAME=Kubernetes 101

ğŸ“Š Summary Table

Step	Command / File	Purpose
1	kubectl create deploy ... -o yaml	Generate deployment YAML
2	env: block in YAML	Add environment variables
3	process.env.VAR_NAME	Access env vars in code
4	docker build & push	Build and push image
5	kubectl apply -f	Deploy updated app
6	kubectl expose deploy	Create service
7	kubectl exec printenv	Verify env vars

ğŸ”‘ Key Takeaways

Environment variables in Kubernetes are injected at the container level.
Use env: field inside Deployment manifest.
Best practice â†’ env var names in UPPERCASE.
Always rebuild & push Docker image after code changes.
Use Services (NodePort/ClusterIP/LoadBalancer) to expose applications.

You can verify env vars via kubectl exec or directly in app code.

âœ¨ Thatâ€™s it for this demo â€” now your app can flexibly adapt using environment variables in Kubernetes!
